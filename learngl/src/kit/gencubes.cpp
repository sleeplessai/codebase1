#include <array>
#include <chrono>
#include <cmath>
#include <concepts>
#include <fstream>
#include <iterator>
#include <numbers>
#include <random>
#include <type_traits>

#include <fmt/core.h>
#include <glm/glm.hpp>

namespace glm {
template <typename VecT>
concept vec3_or_vec2 = std::is_same_v<glm::vec3, VecT> || std::is_same_v<glm::vec2, VecT>;
};

template <glm::vec3_or_vec2 VecT, std::floating_point DataT>
VecT rand_spherial_coords(const VecT center, const DataT radius) {
    constexpr DataT Pi = std::numbers::pi_v<DataT>;

    DataT seed = std::chrono::system_clock::now().time_since_epoch().count();
    static std::mt19937 g(seed);
    std::uniform_real_distribution<DataT> urd(0.f, 2.f * Pi);

    DataT p = urd(g), q = urd(g);
    DataT sin_p = std::sin(p), sin_q = std::sin(q), cos_p = std::cos(p), cos_q = std::cos(q);
    VecT s{};

    if constexpr (std::is_same_v<VecT, glm::vec3>) {
        s.x = sin_p * cos_q;
        s.y = sin_p * sin_q;
        s.z = cos_p;
    } else if constexpr (std::is_same_v<VecT, glm::vec2>) {
        s.x = sin_p;
        s.y = cos_p;
    }
    return center + radius * s; // rvo, whatever:D
}

inline void std_mt19937_call(int const n, glm::vec3 center = glm::vec3{0.f}, float radius = 1.f) {
    std::string out_path{"cube_pos.inc"};
    std::fstream os(out_path, std::ios::out);

    os << "/* generated by `kit::gencubes` */\n";
    for (int i = 0; i < n; ++i) {
        auto o = rand_spherial_coords(center, radius);
        std::string rt_fmt_str = fmt::vformat("glm::vec3({}f,{}f,{}f),\n", fmt::make_format_args(o.x, o.y, o.z));
        os << rt_fmt_str;
    }
}


#if defined(__mt19937_cslarsen_impl)

/* https://github.com/cslarsen/mersenne-twister */
template<typename DataT, typename SizeT = size_t>
struct Mt19937;

template<>
struct Mt19937<uint32_t> {
    using SizeT = size_t;
    using DataT = uint32_t;
    constexpr static SizeT Size{624}, Period{397}, Diff{Size - Period};
    constexpr static DataT Magic{0x9908b0df};

    struct __mt_state {
        std::array<DataT, Size> mt;
        std::array<DataT, Size> mt_tempered;
        SizeT index = Size;
    } state;

    constexpr DataT rand_u32() noexcept {
        if (state.index == Size) {
            gen_numbers();
            state.index = 0;
        }
        return state.mt_tempered[state.index++];
    }

    constexpr void seed(DataT seed_v) {
    // https://github.com/cslarsen/mersenne-twister/blob/c0bdd01d23594d7a95894d17b3264a26847c3a3e/mersenne-twister.cpp#L121-L150
      state.mt[0] = seed_v;
      state.index = Size;

      for (uint_fast32_t i = 1; i < Size; ++i)
        state.mt[i] = 0x6c078965*(state.mt[i-1] ^ state.mt[i-1]>>30) + i;
    }

    inline constexpr DataT M32(DataT x) const {
        return 0x80000000 & x;
    } // 32nd MSB
    inline constexpr DataT L31(DataT x) const {
        return 0x7FFFFFFF & x;
    }; // 31 LSBs
    inline constexpr void Unroll(SizeT& i, DataT& y, DataT expr) {
        y = M32(state.mt[i]) | L31(state.mt[i + 1]);
        state.mt[i] = state.mt[expr] ^ (y>>1) ^ (((int32_t(y)<<31)>>31) & Magic);
        ++i;
    };

    constexpr void gen_numbers() {
    /*
    * For performance reasons, we've unrolled the loop three times, thus
    * mitigating the need for any modulus operations. Anyway, it seems this
    * trick is old hat: http://www.quadibloc.com/crypto/co4814.htm
    */
        SizeT i{0};
        DataT y{};

        // i = [0 ... 226]
        while (i < Diff) {
         /*
         * We're doing 226 = 113*2, an even number of steps, so we can safely
         * unroll one more step here for speed:
         */
            Unroll(i, y, i + Period);
            Unroll(i, y, i + Period); // Unroll more
        }
        // i = [227 ... 622]
        while (i < Size - 1) {
            Unroll(i, y, i - Diff);
        }

        {
            // i = 623, last step rolls over
            y = M32(state.mt[Size - 1]) | L31(state.mt[0]);
            state.mt[Size - 1] = state.mt[Period-1] ^ (y>>1) ^ (((int32_t(y)<<31)>>31) & Magic);
        }

        // Temper all numbers in a batch
        for (SizeT i = 0; i < Size; ++i) {
            y = state.mt[i];
            y ^= y >> 11;
            y ^= y << 7  & 0x9d2c5680;
            y ^= y << 15 & 0xefc60000;
            y ^= y >> 18;
            state.mt_tempered[i] = y;
        }
        state.index = 0;
    }

    void operator()() = delete; // TODO but delete temporarily
};

// TODO: mt19937<uint64_t>
template<>
struct Mt19937<uint64_t>;

constexpr inline void cslarsen_mt19937_call(int const n) noexcept {
    Mt19937<uint32_t> m{};

    for (int i = 0; i < n; ++i) {
        m.rand_u32();
    }
}
#endif

int main(const int, const char** argv) {
    std_mt19937_call(std::atoi(argv[1]), glm::vec3{0.f}, 5.f);
#if defined (__mt19937_cslarsen_impl)
    cslarsen_mt19937_call();
#endif
    return 0;
}
